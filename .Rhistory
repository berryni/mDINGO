plot(network.for.plot.use,    		#the graph to be plotted
layout=layout.fruchterman.reingold,	# the layout method. see the igraph documentation for details
margin=c(0,-0.5,0,-0.5),
main=paste("Differential network for", MIR.name, "targets"),	#specifies the title
#     vertex.size=2,   #can also be made to vary, see V()$size
vertex.label.dist=0.7,			#puts the name labels slightly off the dots
vertex.label.degree=lab.locs,  #defined above
vertex.color='gray',
vertex.frame.color='black', 		#the color of the border of the dots
vertex.label.color='black',		#the color of the name labels
vertex.label.font=2,			#the font of the name labels
vertex.label=V(network.for.plot.use)$name,		#specifies the lables of the vertices. in this case the 'name' attribute is used
vertex.label.cex=0.6			#specifies the size of the font of the labels. can also be made to vary
)
?parallel
??parSapply
library(parallel)
cl <- makeCluster(getOption("cl.cores", 2))
clusterApply(cl, 1:2, get("+"), 3)
xx <- 1
clusterExport(cl, "xx")
clusterCall(cl, function(y) xx + y, 2)
cl <- makeCluster(getOption("cl.cores", 2))
clusterExport(cl, "base", "DINGOparallel")
update.packages("DINGOparallel")
library(glasso)
library(mvtnorm)
library(parallel)
library(glasso)
library(mvtnorm)
library(parallel)
library("DINGOparallel")
#library(igraph)
#library(ggplot2)
#library(scales)
#library(plyr)
#library(matrixStats)
#library(lineprof)
#library(DINGO)
path <- "/home/caclass/R/win-library/3.1/DINGOparallel/R"
sourceDir <- function(path, trace = TRUE, ...) {
for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
if(trace) cat(nm,":")
source(file.path(path, nm), ...)
if(trace) cat("\n")
}
}
# If looping:
#num_rna.l <- c(10,30,100)
#bootstraps.l <- c(1,10,40) #usually want >= 10
#num_samps.l <- c(10,20,30) #even number please
#for testing
num_rna = 10
bootstraps = 2
num_samps = 10
#source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
Y <- matrix(rnorm(num_samps*num_rna), nrow = num_samps, ncol = num_rna)
x <- sample(c(rep(1,num_samps/2), rep(2,num_samps/2)), replace = FALSE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
cl <- makeCluster(getOption("cl.cores", 2))
clusterExport(cl, "base", "DINGOparallel")
?clusterExport
clusterExport(cl, c("base", "DINGOparallel"), envir=environment())
clusterExport(cl, c("base", "DINGOparallel"))
cl <- makeCluster(getOption("cl.cores", 2))
boot.diff <-  parSapply(cl, 1:boot.B, single.boot,
z=z, n=n, tY.org=tY.org, P=P, levels.z=levels.z, w.upper=w.upper)
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
cl <- makeCluster(getOption("cl.cores", 2))
clusterExport(cl, c("base"))#, "DINGOparallel"))
clusterExport(cl, "base")#, "DINGOparallel"))
cl <- makeCluster(getOption("cl.cores", 2))
clusterEvalQ(cl, library(base))
clusterEvalQ(cl, library("DINGOparallel"))
boot.diff <-  parSapply(cl, 1:boot.B, single.boot,
z=z, n=n, tY.org=tY.org, P=P, levels.z=levels.z, w.upper=w.upper)
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
cl <- makeCluster(getOption("cl.cores", 2))
clusterEvalQ(cl, library(base))
clusterEvalQ(cl, library("DINGOparallel"))
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
cl <- makeCluster(getOption("cl.cores", 2))
clusterEvalQ(cl, library("DINGOparallel"))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
length(fit)
names(fit)
fit$boot.diff
num_rna = 10
bootstraps = 4
num_samps = 10
#source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
Y <- matrix(rnorm(num_samps*num_rna), nrow = num_samps, ncol = num_rna)
x <- sample(c(rep(1,num_samps/2), rep(2,num_samps/2)), replace = FALSE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
head(fit$boot.diff)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
update.packages("DINGOparallel")
library("DINGOparallel")
num_rna = 10
bootstraps = 4
num_samps = 10
#source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
Y <- matrix(rnorm(num_samps*num_rna), nrow = num_samps, ncol = num_rna)
x <- sample(c(rep(1,num_samps/2), rep(2,num_samps/2)), replace = FALSE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
update.packages("DINGOparallel")
library("DINGOparallel")
detectCores()
library(glasso)
library(mvtnorm)
library(parallel)
#library("DINGOparallel")
#library(igraph)
#library(ggplot2)
#library(scales)
#library(plyr)
#library(matrixStats)
#library(lineprof)
#library(DINGO)
path <- "Y:/R/win-library/3.1/DINGOparallel/R"
sourceDir <- function(path, trace = TRUE, ...) {
for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
if(trace) cat(nm,":")
source(file.path(path, nm), ...)
if(trace) cat("\n")
}
}
sourceDir(path)
detectCores()
# If looping:
#num_rna.l <- c(10,30,100)
#bootstraps.l <- c(1,10,40) #usually want >= 10
#num_samps.l <- c(10,20,30) #even number please
#for testing
num_rna = 10
bootstraps = 2
num_samps = 10
#source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
Y <- matrix(rnorm(num_samps*num_rna), nrow = num_samps, ncol = num_rna)
x <- sample(c(rep(1,num_samps/2), rep(2,num_samps/2)), replace = FALSE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
library(glasso)
library(mvtnorm)
library(parallel)
#library("DINGOparallel")
#library(igraph)
#library(ggplot2)
#library(scales)
#library(plyr)
#library(matrixStats)
#library(lineprof)
#library(DINGO)
path <- "Y:/R/win-library/3.1/DINGOparallel/R"
sourceDir <- function(path, trace = TRUE, ...) {
for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {
if(trace) cat(nm,":")
source(file.path(path, nm), ...)
if(trace) cat("\n")
}
}
sourceDir(path)
detectCores()
# If looping:
#num_rna.l <- c(10,30,100)
#bootstraps.l <- c(1,10,40) #usually want >= 10
#num_samps.l <- c(10,20,30) #even number please
#for testing
num_rna = 10
bootstraps = 2
num_samps = 10
#source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
Y <- matrix(rnorm(num_samps*num_rna), nrow = num_samps, ncol = num_rna)
x <- sample(c(rep(1,num_samps/2), rep(2,num_samps/2)), replace = FALSE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
source('Y:/R/win-library/3.1/DINGOparallel/R/scoring.boot.parallel.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
dingo <- function(dat,x,rhoarray=NULL,diff.score=T,B=100,verbose=T,cores=1) {
#  Input:
####  - dat : n by p response data
####  - x : length n covariate vector
####  - rhoarray : Candidate tuning parameters of glasso for fitting global network. If it is one value, then we use the value. If it is null, we set the candidates.
####  - diff.score : if TRUE, edge-wise differential scores are calculated from bootstrap standard error.
####  - B : the number of bootstrap samples. It is used if diff.score is TRUE
####  - verbose : if TRUE, the number of bootstrap samples are listed
timer <- vector(mode = "numeric", length = 3)
ptm <- proc.time()[3]
n = nrow(dat)
p = ncol(dat)
II = diag(p)
w.upper = which(upper.tri(II))
w.mat = which(upper.tri(II), arr.ind = T)
# data standardization
mdat = apply(dat,2,mean)
sdat = apply(dat,2,sd)
stddat = t((t(dat) - mdat)/sdat)
###################################
# fit global network using glasso #
###################################
S = cov(stddat)
if (is.null(rhoarray)) {
if (n>p) {rhoarray = exp(seq(log(0.001),log(1),length=100))
}else {rhoarray = exp(seq(log(0.1),log(3),length=100))}
}
BIC = rep(0,length(rhoarray))
for (rh in 1:length(rhoarray)) {
fit.gl1 = glasso(S,rho=rhoarray[rh])
fit.gl2 = glasso(S,rho=rhoarray[rh],w.init=fit.gl1$w,wi.init=fit.gl1$wi)
BIC[rh] = extendedBIC(gamma=0,omegahat=fit.gl2$wi,S=S,n=nrow(dat))
}
rho = rhoarray[which.min(BIC)]
fit.gl1 = glasso(S,rho=rho)
fit.gl2 = glasso(S,rho=rho,w.init=fit.gl1$w,wi.init=fit.gl1$wi)
Omega = fit.gl2$wi
diag.Omega = diag(Omega)
P = -Omega/diag.Omega
diag(P) = 0
if (verbose) cat("Step 1 of DINGO is finished at",date(),"\n")
timer[1] <- proc.time()[3] - ptm
######################################
# fit local group-specific component #
######################################
tY.org = stddat %*% (II-t(P))
mdat = apply(tY.org,2,mean)
sdat = apply(tY.org,2,sd)
std.tY = t((t(tY.org) - mdat)/sdat)
fit.g = Greg.em(std.tY~x)
if (verbose) cat("Step 2 of DINGO is finished at",date(),"\n")
timer[2] <- proc.time()[3] - timer[1] - ptm
if (diff.score) {
if (verbose) cat("Bootstrap scoring is started at", date(),"\n")
#if (cores > detectCores()) cat("Cores specified (", cores, ") is greater than those available (", detectCores(), "). This might be a problem.", sep = "")
#cl <- makeCluster(cores)
boot.fit = scoring.boot.parallel(stddat=stddat,z=x,Omega=Omega,A=fit.g$A,B=fit.g$B,boot.B=B,verbose=verbose,cores=cores)
#stopCluster(cl)
if (verbose) cat("Bootstrap scoring is done at", date(),"\n")
timer[3] <- proc.time()[3] - timer[2] - ptm
return(list(genepair = boot.fit$genepair,levels.x = boot.fit$levels.z,R1=boot.fit$R1,R2=boot.fit$R2,boot.diff=boot.fit$boot.diff,diff.score=boot.fit$diff.score,rho=rho,P=P,Q=fit.g$B,Psi=fit.g$A,step.times=timer))
}else{
genepair = data.frame(gene1 = colnames(dat)[w.mat[, 1]],
gene2 = colnames(stddat)[w.mat[, 2]])
levels.x = unique(x)
R1 = -scaledMat(solve(Sigmax(Q = fit.g$B, P = P, Psi = fit.g$A, x = c(1,
levels.x[1]))))[w.upper]
R2 = -scaledMat(solve(Sigmax(Q = fit.g$B, P = P, Psi = fit.g$A, x = c(1,
levels.x[2]))))[w.upper]
return(list(genepair = genepair,levels.x = levels.x,R1=R1,R2=R2,boot.diff=NULL,diff.score=NULL,rho=rho,P=P,Q=fit.g$B,Psi=fit.g$A,step.times=timer))
}
}
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=1))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
library(DINGOparallel)
source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
source('Y:/R/AML-MDS/code/runDINGO_parTest.R', echo=TRUE)
source('Y:/R/AML-MDS/code/runDINGO_parTest.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=2))
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=8))
source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=8))
source('Y:/R/win-library/3.1/DINGOparallel/R/dingo.R', echo=TRUE)
fit <- try(dingo(dat=Y, x=x, diff.score=TRUE, B=bootstraps, verbose=TRUE, cores=8))
?parSapply
?scoring.boot
?dingo
library(roxygen2)
?document
??document
vignette("rd", package = "roxygen2")
?dingo
?detectCores
getwd()
setwd("..")
install("DINGOparallel")
?install
??install
library(devtools)
install("DINGOparallel")
install("DINGOparallel")
library(DINGOparallel)
?dingo
?dingo
?dingo
library(DINGOparallel)
?dingo
library(devtools)
getwd()
setwd("..")
install("DINGOparallel")
?dingo
library(DINGOparallel)
?dingo
?scoring.boot.parallel
library(devtools)
install()
library(DINGOparallel)
library(DINGOparallel)
?dingo
install()
library(devtools)
install()
library(DINGOparallel)
?dingo
?single.boot
?scoring.boot.parallel
browse.vignettes(DINGO)
browse.vignettes(DINGOparallel)
??browse.vignettes
?vignettes
vignette(DINGO)
vignette(DINGOparallel)
?DINGOparallel
?DINGO-package
?`DINGO-package`
source('Y:/R/AML-MDS/code/runDINGO_parTest.R', echo=TRUE)
library(SpiecEasi)
data(amgut1.filt)
str(amut1.filt)
str(amgut1.filt)
amgut = amgut1.filt
dim(amgut)
head(amgut)
depths = rowSums(amgut)
?norm_to_total
amgut/depths
t(apply(amgut1.filt, 1, norm_to_total))
amgut/depths == t(apply(amgut1.filt, 1, norm_to_total))
all(amgut/depths == t(apply(amgut1.filt, 1, norm_to_total)))
amgut.cs = round(amgut/depths*min(depths))
head(amgut.cs)
rowSums(amgut.cs)
d <- ncol(amgut.cs)
n <- nrow(amgut.cs)
e = d
data(amgut1.filt)
amgut = amgut1.filt
depths = rowSums(amgut)
amgut.cs = round(amgut/depths)
rowSums(amgut.cs)
data(amgut1.filt)
amgut = amgut1.filt
depths = rowSums(amgut)
summary(depths)
amgut.cs = amgut/depths
rowSums(amgut.cs)
amgut.cs = round((amgut/depths)*min(depths))
d <- ncol(amgut.cs)
n <- nrow(amgut.cs)
e = d
Prec = graph2prec(graph)
Cor = cov2cor(prec2cov(Prec))
graph = make_graph('cluster', d, e)
Prec = graph2prec(graph)
Cor = cov2cor(prec2cov(Prec))
X <- synth_comm_from_counts(amgut1.filt.cs, mar=2, distr='zinegbin', Sigma=Cor, n=n)
X <- synth_comm_from_counts(amgut.cs, mar=2, distr='zinegbin', Sigma=Cor, n=n)
graph
summary(graph)
sum(graph)
plot(graph)
plot(graph, type="tile")
myImagePlot(m)
image(graph)
graph[1,1] = 1000
image(graph)
graph[1,1] = 0
image(graph)
X <- synth_comm_from_counts(amgut.cs, mar=2, distr='zinegbin', Sigma=Cor, n=n)
rowSums(graph)
colSums(graph)
dim(X)
se.est <- spiec.easi(X, method='mb', lambda.min.ratio=1e-2, nlambda=15)
dim(se.est)
head(se.est)
str(se.est)
stars.pr(getOptMerge(se.est), graph, verbose=FALSE)
se.est[1]
se.est[2]
se.est[3]
se.est[[3]]
dim(se.est[[3]])
str(se.est)
se.est$path
se.est$refit
image(se.est$refit)
as.matrix(se.est$refit)
image(as.matrix(se.est$refit))
image(graph)
image(graph - as.matrix(se.est$refit))
library(ggplot2)
?ggimage
mat = graph
mat.m = melt(mat)
library(reshape2)
require(ggplot2)
require(reshape2)
mat.m = melt(mat)
head(mat.m)
dim(mat.m)
?melt
mat.m = reshape2::melt(mat)
head(mat.m)
mat = graph
mat.m = reshape2::melt(mat)
dim(mat.m)
mat.m = reshape2::melt.array(mat)
mat.m = melt.array(mat)
mat.m = melt(as.data.frame(mat))
head(mat.m)
testData<-matrix(data=round(runif(25)),nrow=5,ncol=5,dimnames=list(Var1=c(1:5),Var2=c(1:5)))
testData
dim(mat)
typeof(mat)
head(mat)
mat[1:10, 1:10]
mat[1:10, 1:20]
mat
summary(mat)
image(mat)
dimnames(mat) = list(Var1 = c(1:dim(mat)[1]), Var2 = c(1:dim(mat)[2]))
dim(mat)
mat.m = melt(mat)
head(mat.m)
head(mat)
mat
mat = as.matrix(mat)
mat.m = melt(mat)
head(mat.m)
mat = graph
mat.m=  melt(as.matrix(mat))
head(mat.m)
dimnames(mat)
dimnames(mat.m)
ggplot(mat.m, aes(x = `dimnames(mat.m)[[2]][2]``, y = `dimnames(mat.m)[[2]][1]``, fill = `dimnames(mat.m)[[2]][3]``) + geom_raster()
ggplot(mat.m, aes(x = `dimnames(mat.m)[[2]][2]`, y = `dimnames(mat.m)[[2]][1]`, fill = `dimnames(mat.m)[[2]][3]`) + geom_raster()
ggplot(mat.m, aes(x = `dimnames(mat.m)[[2]][2]`, y = `dimnames(mat.m)[[2]][1]`, fill = `dimnames(mat.m)[[2]][3]`)) + geom_raster()
ggplot(mat.m, aes(x = `dimnames(mat.m)[[2]][2]`, y = `dimnames(mat.m)[[2]][1]`, fill = `dimnames(mat.m)[[2]][3]`)) + geom_raster()
ggplot(mat.m, aes(x = Var2, y = Var1, fill = value)) + geom_raster()
image(graph)
ggplot(mat.m, aes(x = Var2, y = Var1, fill = value)) + geom_raster() + scale_fill_continuous(low = "red", high = "white") + theme_bw()
ggimage = function(mat)
{
require(ggplot2)
require(reshape2)
mat.m = melt(as.matrix(mat))
return(ggplot(mat.m, aes(x = Var2, y = Var1, fill = value)) + geom_raster() + scale_fill_continuous(low = "red", high = "white") + theme_bw())
}
ggimage(graph)
image(graph)
p = ggimage(graph)
p + ggtitle("Image of True Prec. Mat")
p + ggtitle("Image of True Prec. Mat") + theme(legend = NULL)
p + ggtitle("Image of True Prec. Mat") + theme(legend = NA)
p + ggtitle("Image of True Prec. Mat") + theme(legend = FALSe)
p + ggtitle("Image of True Prec. Mat") + theme(legend = FALSE)
p + ggtitle("Image of True Prec. Mat") + legend(NULL)
p + ggtitle("Image of True Prec. Mat") + legend()
p + ggtitle("Image of True Prec. Mat") + legend(legend = NULL)
p + ggtitle("Image of True Prec. Mat") + legend(legend = NA)
p + ggtitle("Image of True Prec. Mat") + legend(legend = 0)
p + ggtitle("Image of True Prec. Mat")
p + ggtitle("Image of True Prec. Mat")
ggimage = function(mat)
{
require(ggplot2)
require(reshape2)
mat.m = melt(as.matrix(mat))
return(ggplot(mat.m, aes(x = Var2, y = Var1, fill = value)) + geom_raster() + scale_fill_continuous(low = "white", high = "red") + theme_bw())
}
ggimage(graph)
ggimage(graph) + geom_segment()
ggimage(graph) + geom_segment(xend = 150, yend = 150)
ggimage(graph) + geom_segment(aes(xend = 150, yend = 150))
ggimage(graph) + geom_segment(aes(xstart = 0, ystart = 0, xend = 150, yend = 150))
ggimage(graph) + geom_segment(xstart = 0, ystart = 0, xend = 150, yend = 150)
?geom_segment
ggimage(graph) + geom_segment(x = 0, y = 0, xend = 150, yend = 150)
ggimage = function(mat)
{
require(ggplot2)
require(reshape2)
mat.m = melt(as.matrix(mat))
return(ggplot(mat.m, aes(x = Var2, y = Var1, fill = value)) + geom_raster() + scale_fill_continuous(low = "white", high = "red") + geom_segment(x = 0, y = 0, xend = dim(graph)[2], yend = dim(graph)[1]) + theme_bw())
}
ggimage(graph)
ggimage(graph[1:100,])
ggimage = function(mat)
{
require(ggplot2)
require(reshape2)
mat.m = melt(as.matrix(mat))
return(ggplot(mat.m, aes(x = Var2, y = Var1, fill = value)) + geom_raster() + scale_fill_continuous(low = "white", high = "red") + theme_bw())
}
ggimage(graph[1:100,])
ggimage(graph)
ggimage(se.est$refit)
ggimage(se.est$refit - graph)
ggimage(as.matrix(se.est$refit) - graph)
